
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function for automatic annotation of one whole-brain image stack
% containing neuronal landmarks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Inputs - 
% 1. data - generated by running 'preprocess_data.m'. Contains all
%           necessary information required in the code
% 2. numLabelRemove - num of cells to consisdered missing in images
% 3. num - a variable to keep track of iterations if considering missing
%          cells. If not running iterations set to 1

function annotation_CRF_landmark_neuroPAL(data,out_file,node_pot_type,atlas_dir,varargin)

p = inputParser;
addRequired(p,'data',@ischar)
addRequired(p,'out_file',@ischar)
addRequired(p,'node_pot_type',@checkNodePotType)
addParameter(p,'weights',[0,0,0,0,1],@checkWeights)
parse(p,data,out_file,node_pot_type,varargin{:})

rng shuffle
addpath(genpath('UGM'))

%%% load atlas data
load(atlas_dir);


%%% load coordinates data

% take neurons coordinates to AP, LR, DV axis
% mu_r_centered = mu_r - repmat(mean(mu_r),size(mu_r,1),1);
% X = mu_r_centered*PA';
% Y = mu_r_centered*LR';
% Z = mu_r_centered*DV';
load(data);

X= mu_r(:,1);
Y= mu_r(:,2);
Z= mu_r(:,3);
X_norm = (X-min(X))/(max(X)-min(X));

%%% Create spatial neighborhood. Used to calculate proximity relationship
%%% feature
K = 6;
pos = [mu_r(:,1),mu_r(:,2),mu_r(:,3)];
euc_dist = repmat(diag(pos*pos'),1,size(pos,1)) + repmat(diag(pos*pos')',size(pos,1),1) - 2*pos*pos';
[sort_euc_dist,sort_index] = sort(euc_dist,2);
adj = zeros(size(X,1),size(X,1));
for i = 1:size(adj,1)
    adj(i,sort_index(i,2:K+1)) = 1;
end
adj = max(adj,adj');
G = graph(adj);
geo_dist_r = adj; %distances(G); infinity appeared but I'm not using geodist so I'm replacing it with a random matrix


%%% initialize graphical model
adj = ones(size(X,1),size(X,1)); % fully connected graph structure of CRF
adj = adj - diag(diag(adj));
nStates = size(Neuron_head,1);
nNodes = size(X,1);
edgeStruct = UGM_makeEdgeStruct(adj,nStates,0);

%%% create node potentials. Two methods can be used to initialize node
%%% potentials. 1) Uniform probability of each node taking each label in
%%% atlas. 2) Potential based on distance along AP axis
if strcmp(node_pot_type,'uniform')
    node_pot =  ones(nNodes,nStates);
elseif strcmp(node_pot_type,'ap')
    loc_sigma = 0.2;
    node_pot = zeros(nNodes,nStates);
    for i = 1:nNodes
        node_pot(i,:) = diag(exp(-((ones(size(X_rot_norm))*X_norm(i,1) - X_rot_norm)*(ones(size(X_rot_norm))*X_norm(i,1) - X_rot_norm)')/(2*loc_sigma^2)))';
    end
elseif strcmp(node_pot_type,'reg')
    addpath(genpath('CPD2'))
    node_pot = reg_based_node_potential(X,Y,Z,X_rot,Y_rot,Z_rot);
elseif strcmp(node_pot_type,'col')
    if isempty(color_atlas)
        disp("Please provide color atlas path (last argument of the function). Exiting.")
    else
        node_pot = zeros(size(color_data,1),size(Neuron_head,1));
        for i= 1: size(color_data,1)
            for j= 1: size(Neuron_head,1)
                %color_dist= norm(color_data(i,:) - color_atlas(j,:));
                FN= "n" + num2str(j);
                color_dist = mahal(color_data(i,:), color_atlas.(FN));
                node_pot(i,j) = 1/color_dist; %exp(exp(-color_dist^2)); %10*exp(-color_dist^2);
            end
            node_pot(i,:)= node_pot(i,:)./ sum(node_pot(i,:));
        end
    end
end
%disp('2. Created node potentials')

%%% create edge potentials
lambda_PA = p.Results.weights(1,1);
lambda_LR = p.Results.weights(1,2);
lambda_DV = p.Results.weights(1,3);
lambda_geo = p.Results.weights(1,4);
lambda_angle = p.Results.weights(1,5);
for i = 1:edgeStruct.nEdges
    node1 = edgeStruct.edgeEnds(i,1);
    node2 = edgeStruct.edgeEnds(i,2);
    angle_matrix = get_relative_angles_updated_atlas(X,Y,Z,node1,node2,angle_vec_atlas); % deleted X_rot, Y_rot, Z_rot
    %angle_matrix = get_relative_angles(X_rot,Y_rot,Z_rot,X,Y,Z,node1,node2);
    if X(node1,1) < X(node2,1)
        if Y(node1,1) < Y(node2,1)
            if Z(node1,1) < Z(node2,1)
                pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            else
                pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            end
        else
            if Z(node1,1) < Z(node2,1)
                pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            else
                pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            end
        end
    else
        if Y(node1,1) < Y(node2,1)
            if Z(node1,1) < Z(node2,1)
                pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            else
                pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            end
        else
            if Z(node1,1) < Z(node2,1)
                pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            else
                pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
            end
        end
    end
    pot(find(pot<0.01)) = 0.001; %  small potential of incompatible matches
    pot = pot - diag(diag(pot)) + 0.001*eye(size(pot,1)); 
    edge_pot(:,:,i) = pot;
end
%disp('3. Created edge potentials')

%%% clamp potential based on landmarks
clamped = zeros(nNodes,1);

%%% Optimize graphical model using Loopy Belief Propagation
%disp('4. Starting optimization')

%simultaneous labeling
[nodeBel,edgeBel,logZ] = UGM_Infer_Conditional(node_pot,edge_pot,edgeStruct,clamped,@UGM_Infer_LBP);
conserved_nodeBel = nodeBel; %node belief matrix to maintain marginal probabilities after clamping in subsequent steps
% optimal_decode = UGM_Decode_Conditional(node_pot,edge_pot,edgeStruct,clamped,@UGM_Decode_LBP);
[sort_nodeBel,nodeBel_sort_index] = sort(nodeBel,2,'descend');
curr_labels = nodeBel_sort_index(:,1:5);


%%% handle duplicate assignments 
% disp('5. Resolving duplicates and re-running optimization')
% orig_state_array = [1:1:size(Neuron_head,1)]';
% if exist('landmark_to_neuron_map','var')
%     clamped_neurons = landmark_to_neuron_map;
% end
% 
% node_label = duplicate_labels_neuroPAL(curr_labels,X,Y,Z,PA_matrix,LR_matrix,DV_matrix,geo_dist,geo_dist_r,lambda_geo,clamped_neurons);
% cnt = 2;
% while find(node_label(:,1) == 0)
%     assigned_nodes = find(node_label(:,1) ~= 0);
%     assigned_labels = node_label(node_label(:,1) ~= 0,1);
%     unassigned_nodes = find(node_label(:,1) == 0);
% 
%     if strcmp(node_pot_type,'uniform')
%         node_pot =  ones(nNodes,nStates);
%     else
%         loc_sigma = 0.2;
%         node_pot = zeros(nNodes,nStates);
%         for i = 1:nNodes
%             node_pot(i,:) = diag(exp(-((ones(size(X_rot_norm))*X_norm(i,1) - X_rot_norm)*(ones(size(X_rot_norm))*X_norm(i,1) - X_rot_norm)')/(2*loc_sigma^2)))';
%         end
%     end
%     node_pot(unassigned_nodes,assigned_labels) = 0;
%     node_pot(find(node_pot<0.001)) = 0.001;
%     edge_pot = zeros(nStates,nStates,edgeStruct.nEdges);
% 
%     for i = 1:size(edgeStruct.edgeEnds,1)
%         node1 = edgeStruct.edgeEnds(i,1);
%         node2 = edgeStruct.edgeEnds(i,2);
%         angle_matrix = get_relative_angles_updated_atlas(X_rot,Y_rot,Z_rot,X,Y,Z,node1,node2,angle_vec_atlas);
%         %angle_matrix = get_relative_angles(X_rot,Y_rot,Z_rot,X,Y,Z,node1,node2);
%         if X(node1,1) < X(node2,1)
%             if Y(node1,1) < Y(node2,1)
%                 if Z(node1,1) < Z(node2,1)
%                     pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 else
%                     pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 end
%             else
%                 if Z(node1,1) < Z(node2,1)
%                     pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 else
%                     pot = exp(lambda_PA*PA_matrix).*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 end
%             end
%         else
%             if Y(node1,1) < Y(node2,1)
%                 if Z(node1,1) < Z(node2,1)
%                     pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 else
%                     pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix).*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 end
%             else
%                 if Z(node1,1) < Z(node2,1)
%                     pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix).*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 else
%                     pot = exp(lambda_PA*PA_matrix').*exp(lambda_DV*DV_matrix').*exp(lambda_LR*LR_matrix').*exp(exp(-lambda_geo*(geo_dist-geo_dist_r(node1,node2)).^2)).*exp(lambda_angle*angle_matrix);
%                 end
%             end
%         end
% 
%         if node_label(node1,1) == 0 && node_label(node2,1) == 0 % unassigned-unassigned nodes
%             pot(assigned_labels,assigned_labels) = 0;
%         elseif node_label(node1,1) == 0 && node_label(node2,1) ~= 0 % unassigned-assigned nodes
%             pot(assigned_labels,:) = 0;
%         elseif node_label(node1,1) ~= 0 && node_label(node2,1) == 0 % assigned-unassigned nodes
%             pot(:,assigned_labels) = 0;
%         else
%         end 
%         pot(find(pot<0.01)) = 0.001; %  small potential of incompatible matches
%         pot = pot - diag(diag(pot)) + 0.001*eye(size(pot,1));
%         edge_pot(:,:,i) = pot;
%     end
% 
%     clamped = zeros(nNodes,1);
%     clamped(assigned_nodes) = assigned_labels;
% 
%     [nodeBel,edgeBel,logZ] = UGM_Infer_Conditional(node_pot,edge_pot,edgeStruct,clamped,@UGM_Infer_LBP);
%     conserved_nodeBel(unassigned_nodes,:) = nodeBel(unassigned_nodes,:);
%     [sort_nodeBel,nodeBel_sort_index] = sort(nodeBel,2,'descend');
% 
%     curr_labels = nodeBel_sort_index(:,1);
%     [PAscore,LRscore,DVscore,geodistscore,totscore] = consistency_scores(nNodes,curr_labels,X,Y,Z,PA_matrix,LR_matrix,DV_matrix,geo_dist,geo_dist_r);
%     PA_score(:,cnt) = PAscore;
%     LR_score(:,cnt) = LRscore;
%     DV_score(:,cnt) = DVscore;
%     geodist_score(:,cnt) = geodistscore;
%     tot_score(:,cnt) = totscore;
% 
%     node_label = duplicate_labels_neuroPAL(curr_labels,X,Y,Z,PA_matrix,LR_matrix,DV_matrix,geo_dist,geo_dist_r,lambda_geo,clamped_neurons);
%     cnt = cnt + 1;
% end

%%% save experiments results
%disp('6. Saving prediction')
experiments = struct();
experiments(1).K = K;
experiments(1).lambda_PA = lambda_PA;
experiments(1).lambda_LR = lambda_LR;
experiments(1).lambda_DV = lambda_DV;
experiments(1).lambda_geo = lambda_geo;
experiments(1).lambda_angle = lambda_angle;
experiments(1).node_label= curr_labels;
experiments(1).Neuron_head = Neuron_head;
save(out_file,'experiments')
end


function TF = checkWeights(x)
   TF = false;
   if or(size(x,2) > 5,size(x,2) < 5) 
       error('weights must be 1-by-5 array');
   else
       TF = true;
   end
end

function TF = checkNodePotType(x)
    TF = false;
    validNodePotType = {'uniform','ap','reg','col'};
    TF = any(validatestring(x,validNodePotType));
end